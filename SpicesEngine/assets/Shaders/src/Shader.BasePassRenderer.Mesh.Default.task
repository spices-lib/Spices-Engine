/**
* @file Shader.BasePassRenderer.Mesh.Default.task.
* @brief This Shader Defines BasePass Renderer Mesh SubPass Default Task Shader Behaver.
* @author Spices.
*/

/************************************Pre Compile*******************************************/

#version 460
#extension GL_EXT_mesh_shader : require
#extension GL_GOOGLE_include_directive : enable

#include "Header/ShaderCommon.h"
#include "Header/ShaderPreRendererLayout.glsl"
#include "Header/ShaderFunctionLibrary.glsl"

/*****************************************************************************************/

/*************************************Task Input******************************************/

layout (local_size_x=1, local_size_y=1, local_size_z=1) in;

/*****************************************************************************************/

/*************************************Task Output*****************************************/

taskPayloadSharedEXT uint workgroupId;

/*****************************************************************************************/

/*********************************Push Constant*******************************************/

/**
* @brief push constant.
*/
layout(push_constant) uniform Push {
	PushConstantMesh push;   
};

/*****************************************************************************************/

/************************************Specific Data****************************************/

layout(buffer_reference, scalar, buffer_reference_align = 8) buffer Meshlets {
    Meshlet i[];
};

/*****************************************************************************************/

/**********************************Shader Entry*******************************************/

void main()
{
    Meshlet meshlet     = Meshlets(push.desc.meshletAddress).i[gl_WorkGroupID.x];
    mat4 mvp            = view.projection * view.view * push.model;
    
	vec4 ro             = view.inView * vec4(0.0f, 0.0f, 0.0f, 1.0f);
    vec4 worldCenter    = push.model * vec4(meshlet.boundCenter, 1.0f);
    vec3 dis            = worldCenter.xyz - ro.xyz;

    vec4 frustumPlanes[5];
    ExtractFrustumPlanes(view.projection, frustumPlanes);
    vec4 viewSpaceBoundCenter = view.view * push.model * vec4(meshlet.boundCenter, 1.0f);
    
    bool frustumCulled = !IsInsideFrustum_Sphere(frustumPlanes, viewSpaceBoundCenter.xyz, meshlet.boundRadius);
    
    bool normalConeCulled = IsConeBackfacing(meshlet.coneApex, meshlet.coneAxis, meshlet.coneCutoff, ro.xyz);
    
    if(frustumCulled)
    {
        EmitMeshTasksEXT(0, 0, 0);
        return;
    }
    else
    {
        workgroupId = gl_WorkGroupID.x;
        EmitMeshTasksEXT(1, 1, 1);
        return;
    }
}