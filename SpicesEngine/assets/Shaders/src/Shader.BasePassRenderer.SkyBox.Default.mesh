/**
* @file Shader.BasePassRenderer.Mesh.SkyBox.mesh.
* @brief This Shader Defines BasePass Renderer Mesh SubPass SkyBox Mesh Shader Behaver.
* @author Spices.
*/

/************************************Pre Compile*******************************************/

#version 460
#extension GL_EXT_mesh_shader                 : require   /* @brief Declear this as mesh shader. */
#extension GL_GOOGLE_include_directive        : enable    /* @brief Enable include feature.      */
#extension GL_EXT_control_flow_attributes     : require   /* @brief Enable flow butter control.  */

#include "Header/ShaderPreRendererLayout.glsl"

/*****************************************************************************************/

/*************************************Mesh Input******************************************/

/**
* @brief 8 * 8 * 2 = 128(Local Work Groups Count) ~ 126(Nvidia Recommended Meshlet Primitives) ~ 124(MeshOptimizer Required Meshlet Primitives)
* But subgroup size only support 32 in nvidia / 64 in amd.
* Thereforce use iter to reach all primitives in meshlet.
*/
layout(local_size_x = 8, local_size_y = 8, local_size_z = 2) in;

/**
* @brief task padload receive from task shader.
*/
taskPayloadSharedEXT struct Task 
{
    uint meshletIndex[SUBGROUP_SIZE];    /* @brief mesh shader hanled meshlet id. */
} 
task;    

/*****************************************************************************************/

/*************************************Mesh Output*****************************************/

/**
* @brief Output triangles meshlet per workgroup.
*/
layout(triangles, max_vertices = MESHLET_NVERTICES, max_primitives = MESHLET_NPRIMITIVES) out;

/**
* @brief Output data to fragment shader.
*/
layout(location = 0) out struct MeshOut 
{
    vec3 localPosition;
    vec3 worldPosition;
} 
meshOut[];

layout(location = 2) out flat uint meshletId[];       /* @brief Meshlet ID.     */

/*****************************************************************************************/

/*********************************Push Constant*******************************************/

/**
* @brief push constant.
*/
layout(push_constant) uniform Push 
{
	PushConstantMesh push;   /* @see PushConstantMesh. */
};

/*****************************************************************************************/

/************************************Specific Data****************************************/

layout(buffer_reference, scalar, buffer_reference_align = 8) buffer Vertices 
{ 
    Vertex v[];           
};

layout(buffer_reference, scalar, buffer_reference_align = 8) buffer Indices 
{ 
    ivec3 i[]; 
};

layout(buffer_reference, scalar, buffer_reference_align = 8) buffer Meshlets 
{
    Meshlet i[];
};

/*****************************************************************************************/

/**********************************Shader Entry*******************************************/

void main()
{
    uint id = task.meshletIndex[gl_WorkGroupID.x];

    Vertices vertices   = Vertices(push.desc.vertexAddress);
    Indices indices     = Indices(push.desc.indexAddress);
    Meshlet meshlet     = Meshlets(push.desc.meshletAddress).i[id];

    mat4 mvp = view.projection * view.view * push.model;
    mat3 m3model = mat3(transpose(inverse(push.model)));

    const uint localId = gl_LocalInvocationIndex;
        
    if(localId >= meshlet.nPrimitives) return;
    
    ivec3 index = indices.i[meshlet.primitiveOffset + localId];
    
    Vertex vts[3] = { vertices.v[index.x], vertices.v[index.y], vertices.v[index.z] };
        
    index -= ivec3(meshlet.vertexOffset);
    uint arrayIndices[3] = { index.x, index.y, index.z };
        
    gl_PrimitiveTriangleIndicesEXT[localId] =  uvec3(index.x, index.y, index.z);
    
    [[unroll]]
    for(int j = 0; j < 3; j++)
    {
        Vertex vt = vts[j];
    
        gl_MeshVerticesEXT[arrayIndices[j]].gl_Position = mvp * vec4(vt.position, 1.0f);
            
        meshOut[arrayIndices[j]].localPosition = vt.position;
        meshOut[arrayIndices[j]].worldPosition = vec3(push.model * vec4(vt.position, 1.0f));
        meshletId[arrayIndices[j]]             = id;
    }

    
    SetMeshOutputsEXT(meshlet.nVertices, meshlet.nPrimitives);
}

/*****************************************************************************************/