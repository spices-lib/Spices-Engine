/**
* @file Shader.BasePassRenderer.Mesh.Default.mesh.
* @brief This Shader Defines BasePass Renderer Mesh SubPass Default Mesh Shader Behaver.
* @author Spices.
*/

/************************************Pre Compile*******************************************/

#version 460
#extension GL_EXT_mesh_shader                 : require
#extension GL_GOOGLE_include_directive        : enable    
#extension GL_EXT_control_flow_attributes     : require

#include "Header/ShaderPreRendererLayout.glsl"

/*****************************************************************************************/

/*************************************Mesh Input******************************************/

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

/*****************************************************************************************/

/*************************************Mesh Output*****************************************/

layout(triangles, max_vertices = 63, max_primitives = 21) out;

layout(location = 0) out struct VertOut {
    vec3 position;                                
    vec3 normal;                                  
    vec3 color;                                   
    vec2 texCoord;                         
} vertOut[];

layout(location = 10) out uint seed[];

/*****************************************************************************************/

/*********************************Push Constant*******************************************/

/**
* @brief push constant.
*/
layout(push_constant) uniform Push {
	PushConstantMesh push;   
};

/*****************************************************************************************/


layout(buffer_reference, scalar, buffer_reference_align = 8) buffer Vertices { 
    Vertex v[];           
};

layout(buffer_reference, scalar, buffer_reference_align = 8) buffer Indices { 
    ivec3 i[]; 
};

/**********************************Shader Entry*******************************************/

void main()
{
    Vertices vertices   = Vertices(push.desc.vertexAddress);
    Indices indices     = Indices(push.desc.indexAddress);
    uint VerticesCount  = push.desc.verticesCount;
    uint IndicesCount   = push.desc.indicesCount;

    uint id = gl_GlobalInvocationID.x;

    mat4 mvp = view.projection * view.view * push.model;
    mat3 m3model = mat3(transpose(inverse(push.model)));
	
	uint nIndices = 0;
	[[unroll]]
    for(uint i = 0; i < 21; i++)
    {   
        if(21 * id + i >= IndicesCount) break;
        ivec3 index = indices.i[21 * id + i];
        gl_PrimitiveTriangleIndicesEXT[i] =  uvec3(3 * i + 0, 3 * i + 1, 3 * i + 2);
        
        Vertex v0 = vertices.v[index.x];
        Vertex v1 = vertices.v[index.y];
        Vertex v2 = vertices.v[index.z];
        
        gl_MeshVerticesEXT[3 * i + 0].gl_Position = mvp * vec4(v0.position, 1.0f);
        gl_MeshVerticesEXT[3 * i + 1].gl_Position = mvp * vec4(v1.position, 1.0f);
        gl_MeshVerticesEXT[3 * i + 2].gl_Position = mvp * vec4(v2.position, 1.0f);
        
        vertOut[3 * i + 0].position = vec3(push.model * vec4(v0.position, 1.0f));
        vertOut[3 * i + 0].normal   = normalize(m3model * v0.normal);
        vertOut[3 * i + 0].color    = v0.color;
        seed[3 * i + 0]     = id;
        vertOut[3 * i + 0].texCoord = v0.texCoord;
        
        vertOut[3 * i + 1].position = vec3(push.model * vec4(v1.position, 1.0f));
        vertOut[3 * i + 1].normal   = normalize(m3model * v1.normal);
        vertOut[3 * i + 1].color    = v1.color;
        seed[3 * i + 1]     = id;
        vertOut[3 * i + 1].texCoord = v1.texCoord;
        
        vertOut[3 * i + 2].position = vec3(push.model * vec4(v2.position, 1.0f));
        vertOut[3 * i + 2].normal   = normalize(m3model * v2.normal);
        vertOut[3 * i + 2].color    = v2.color;
        seed[3 * i + 2]     = id;
        vertOut[3 * i + 2].texCoord = v2.texCoord;
        
        nIndices++;
    }
    
    SetMeshOutputsEXT(3 * nIndices, nIndices);
}

/*****************************************************************************************/