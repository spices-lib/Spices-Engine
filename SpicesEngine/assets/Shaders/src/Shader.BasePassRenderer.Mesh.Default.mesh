/**
* @file Shader.BasePassRenderer.Mesh.Default.mesh.
* @brief This Shader Defines BasePass Renderer Mesh SubPass Default Mesh Shader Behaver.
* @author Spices.
*/

/************************************Pre Compile*******************************************/

#version 460
#extension GL_EXT_mesh_shader                 : require   /* @brief Declear this as mesh shader. */
#extension GL_GOOGLE_include_directive        : enable    /* @brief Enable include feature.      */
#extension GL_EXT_control_flow_attributes     : require   /* @brief Enable flow butter control.  */

#include "Header/ShaderPreRendererLayout.glsl"

/*****************************************************************************************/

/*************************************Mesh Input******************************************/

/**
* @brief 8 * 8 * 2 = 128(Local Work Groups Count) ~ 126(Nvidia Recommended Meshlet Primitives) ~ 124(MeshOptimizer Required Meshlet Primitives)
*/
layout(local_size_x = 8, local_size_y = 8, local_size_z = 2) in;

/**
* @brief task padload receive from task shader.
*/
taskPayloadSharedEXT uint workgroupId;    /* @brief mesh shader hanled meshlet id(as workgroupid). */

/*****************************************************************************************/

/*************************************Mesh Output*****************************************/

/**
* @brief Output triangles meshlet per workgroup.
*/
layout(triangles, max_vertices = MESHLET_NVERTICES, max_primitives = MESHLET_NPRIMITIVES) out;

/**
* @brief Mesh Shader Output to Fragment Shader.
*/
layout(location = 0) out Pixel pixel[];               /* @brief Pixel Data.     */
layout(location = 4) out flat uint meshletId[];       /* @brief Meshlet ID.     */

/*****************************************************************************************/

/*********************************Push Constant*******************************************/

/**
* @brief push constant.
*/
layout(push_constant) uniform Push {
	PushConstantMesh push;   /* @see PushConstantMesh. */
};

/*****************************************************************************************/

/************************************Specific Data****************************************/

layout(buffer_reference, scalar, buffer_reference_align = 8) buffer Vertices { 
    Vertex v[];           
};

layout(buffer_reference, scalar, buffer_reference_align = 8) buffer Indices { 
    ivec3 i[]; 
};

layout(buffer_reference, scalar, buffer_reference_align = 8) buffer Meshlets {
    Meshlet i[];
};

/*****************************************************************************************/

/**********************************Shader Entry*******************************************/

void main()
{
    uint id = workgroupId;

    Vertices vertices   = Vertices(push.desc.vertexAddress);
    Indices indices     = Indices(push.desc.indexAddress);
    Meshlet meshlet     = Meshlets(push.desc.meshletAddress).i[id];

    if(gl_LocalInvocationIndex >= meshlet.nPrimitives) return;

    mat4 mvp = view.projection * view.view * push.model;
    mat3 m3model = mat3(transpose(inverse(push.model)));
    
    ivec3 index = indices.i[meshlet.primitiveOffset + gl_LocalInvocationIndex];

    Vertex vts[3] = { vertices.v[index.x], vertices.v[index.y], vertices.v[index.z] };
    
    index -= ivec3(meshlet.vertexOffset);
    uint arrayIndices[3] = { index.x, index.y, index.z };
    
    gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationIndex] =  uvec3(index.x, index.y, index.z);
    
    gl_MeshVerticesEXT[index.y].gl_Position = mvp * vec4(vts[1].position, 1.0f);
    gl_MeshVerticesEXT[index.z].gl_Position = mvp * vec4(vts[2].position, 1.0f);

    [[unroll]]
    for(int i = 0; i < 3; i++)
    {
        Vertex vt = vts[i];

        gl_MeshVerticesEXT[arrayIndices[i]].gl_Position = mvp * vec4(vt.position, 1.0f);
        
        pixel[arrayIndices[i]].position  = vec3(push.model * vec4(vt.position, 1.0f));
        pixel[arrayIndices[i]].normal    = normalize(m3model * vt.normal);
        pixel[arrayIndices[i]].color     = vt.color;
        pixel[arrayIndices[i]].texCoord  = vt.texCoord;
        meshletId[arrayIndices[i]]       = id;
    }
    
    SetMeshOutputsEXT(meshlet.nVertices, meshlet.nPrimitives);
}

/*****************************************************************************************/