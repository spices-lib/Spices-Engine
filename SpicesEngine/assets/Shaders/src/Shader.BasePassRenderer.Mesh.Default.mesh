/**
* @file Shader.BasePassRenderer.Mesh.Default.mesh.
* @brief This Shader Defines BasePass Renderer Mesh SubPass Default Mesh Shader Behaver.
* @author Spices.
*/

/************************************Pre Compile*******************************************/

#version 460
#extension GL_EXT_mesh_shader                 : require   /* @brief Declear this as mesh shader. */
#extension GL_GOOGLE_include_directive        : enable    /* @brief Enable include feature.      */
#extension GL_EXT_control_flow_attributes     : require   /* @brief Enable flow butter control.  */

#include "Header/ShaderPreRendererLayout.glsl"

/*****************************************************************************************/

/*************************************Mesh Input******************************************/

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

/**
* @brief task padload receive from task shader.
*/
taskPayloadSharedEXT uint workgroupId;    /* @brief mesh shader hanled meshlet id(as workgroupid). */

/*****************************************************************************************/

/*************************************Mesh Output*****************************************/

/**
* @brief Output triangles meshlet per workgroup.
*/
layout(triangles, max_vertices = MESHLET_NVERTICES, max_primitives = MESHLET_NPRIMITIVES) out;

/**
* @brief Mesh Shader Output to Fragment Shader.
*/
layout(location = 0) out Pixel pixel[];               /* @brief Pixel Data.     */
layout(location = 4) out flat uint meshletId[];       /* @brief Meshlet ID.     */

/*****************************************************************************************/

/*********************************Push Constant*******************************************/

/**
* @brief push constant.
*/
layout(push_constant) uniform Push {
	PushConstantMesh push;   /* @see PushConstantMesh. */
};

/*****************************************************************************************/

/************************************Specific Data****************************************/

layout(buffer_reference, scalar, buffer_reference_align = 8) buffer Vertices { 
    Vertex v[];           
};

layout(buffer_reference, scalar, buffer_reference_align = 8) buffer Indices { 
    ivec3 i[]; 
};

layout(buffer_reference, scalar, buffer_reference_align = 8) buffer Meshlets {
    Meshlet i[];
};

/*****************************************************************************************/

/**********************************Shader Entry*******************************************/

void main()
{
    uint id = workgroupId;

    Vertices vertices   = Vertices(push.desc.vertexAddress);
    Indices indices     = Indices(push.desc.indexAddress);
    Meshlet meshlet     = Meshlets(push.desc.meshletAddress).i[id];
    
    mat4 mvp = view.projection * view.view * push.model;
    mat3 m3model = mat3(transpose(inverse(push.model)));

    [[unroll]]
    for(uint i = 0; i < meshlet.nVertices; i++)
    {
        Vertex vt = vertices.v[meshlet.vertexOffset + i];

        gl_MeshVerticesEXT[i].gl_Position = mvp * vec4(vt.position, 1.0f);

        pixel[i].position  = vec3(push.model * vec4(vt.position, 1.0f));
        pixel[i].normal    = normalize(m3model * vt.normal);
        pixel[i].color     = vt.color;
        pixel[i].texCoord  = vt.texCoord;
        meshletId[i]       = id;
    }

	[[unroll]]
    for(uint i = 0; i < meshlet.nPrimitives; i++)
    {
        ivec3 index = indices.i[meshlet.primitiveOffset + i] - ivec3(meshlet.vertexOffset);
        gl_PrimitiveTriangleIndicesEXT[i] =  uvec3(index.x, index.y, index.z);
    }
    
    SetMeshOutputsEXT(meshlet.nVertices, meshlet.nPrimitives);
}

/*****************************************************************************************/